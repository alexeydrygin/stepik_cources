## Общий принцип редактирования сообщений
--------------------------------------

Возможность отредактировать сообщение позволяет улучшить так называемый user expirience - тот самый пользовательский опыт, который все стараются улучшить, чтобы сделать нашу жизнь, хотя бы в каких-то моментах, удобнее. Благодаря большому количеству мобильных приложений, мы все давно привыкли к определенному способу взаимодействия - мы нажимаем нарисованные кнопки и тут же на этом же экране получаем реакцию на нажатие. При этом чаще всего весь экран, с точки зрения пользователя, не перерисовывается, а меняются только какие-то его части. Вот, и в телеграм-боте, при нажатии на инлайн-кнопку, изменение старого сообщения, в котором была нажата кнопка, выглядит намного лучше, чем приходящее новое сообщение.

Мы с вами уже пользовались редактированием сообщения, когда писали бота-книгу. Каждая страница книги не приходила в чат в виде нового сообщения, а заменяла собой старую страницу с кнопками. Давайте еще раз остановимся на этом подробнее, тем более, что у редактирования сообщений есть ряд неочевидных нюансов.

Но сначала немного экспериментов для наглядности. Вообще, есть три основных способа заменить старое сообщение новым при нажатии на инлайн-кнопку:

*   Через отправку нового сообщения без удаления старого
*   Через отправку нового сообщения с удалением старого
*   Через редактирование старого сообщения

Давайте для лучшего понимания реализуем все 3 способа. Вы сами сможете посмотреть как они себя ведут и решить в каких случаях какой из них более применим.

### Способ 1. Отправка нового сообщения без удаления старого

Напишем очень простого бота, который по команде /start или /joke будет отправлять в чат текстовое сообщение с какой-нибудь шуткой и кнопкой "Хочу еще!". При нажатии на эту кнопку будет приходить новое сообщение с новой шуткой и такой же кнопкой.

    import random
    
    from aiogram import Bot, Dispatcher
    from aiogram.filters import Command, Text
    from aiogram.types import (CallbackQuery, InlineKeyboardButton,
                               InlineKeyboardMarkup, Message)
    
    # Вместо BOT TOKEN HERE нужно вставить токен вашего бота,
    # полученный у @BotFather
    BOT_TOKEN = 'BOT TOKEN HERE'
    
    bot: Bot = Bot(BOT_TOKEN)
    dp: Dispatcher = Dispatcher()
    
    
    jokes: dict[int, str] = {
        1: 'с хабра, описание фильмов Матрица\n\nСудя по всему, в городе машин либо очень либеральный мэр, либо очень криворукие сисадмины. Иначе как объяснить, что свободные люди беспрепятственно подключаются к вражеской ИТ-системе? Причем удаленно из тарантаса, летающего по канализации! Т.е. мало того, что у машин в сточных трубах развернут высокоскоростной Wi-Fi, так они еще и пускают в свою сеть всех подряд, позволяя неавторизованным пользователям получать данные из системы, вносить в нее изменения и общаться между собой. Красота!',
        2: '- У меня на одном курсе был фин, он приехал к нам т.к. был очарован культурой гопников. Он хотел проникнуться ею у первоисточника и подтянуть мат. И вот где-то в Питере он припал к истокам, все-все выучил и загорелся желанием принести культуру другим иностранцам группы. А там были бразильцы, немцы итальянцы, французы и китаец. И вот захожу как-то я в группу и там хором повторяют слова "ъуъ" и "съка" с шестью разными акцентами.\n- Хотелось бы послушать, как они говорили "ъуъ"',
        3: 'Я в восторге от наших учителей.\nСыну в школе дали домашнее задание, где, среди прочего, был вопрос "как связаны буква А4 и бык?"\nРассказал ему про финикийский алфавит, как первую фонетическую письменность. Что там была буква "алеф", очень похожая на нашу современную "А", и что слово "алеф" означало "бык". Что, возможно, букву так назвали, потому что если развернуть ее, то она похожа на морду быка с рогами.\nЕще очень радовался, что детям во втором классе такие вещи рассказывают.\nУчительница поставила ребенку двойку, заявив, что он фантазировал в домашнем задании. А правильный ответ: если к слову "бык" добавить "а", получится родительный падеж.\nЯ не планировал в таком раннем возрасте рассказывать сыну, что половина окружающих людей - идиоты, но, видимо, придется :-)',
        4: 'у меня на балконе сосулька растет метровая, прямо над машиной, которая ссигналит каждую ночь. Я эту сосульку из распылителя подкармливаю.',
        5: 'xx: Мне сейчас спам пришел "Я живу в доме напротив, вот моя ссылка *адрес ссылки*. Давай познакомимся". Я ответил, что живу напротив морга и меня пугают такие знакомства',
        6: 'xxx: В командировке на съемной квартире нужна была марля, чтобы погладить футболку. Начал шариться по всем ящикам. Марлю не нашел, зато нашел ключ в шкафу между простынями. Вспомнил, что один ящик в этом шкафу был заперт. Попробовал открыть его найденным ключом. Открыл. Внутри нашел марлю. Не зря в квесты играл..'}
    
    
    # Функция, генерирующая случайное число в диапазоне от 1 до длины словаря jokes
    def random_joke() -> int:
        return random.randint(1, len(jokes))
    
    
    # Этот хэндлер будет срабатывать на команды "/start" и "/joke"
    @dp.message(Command(commands=['start', 'joke']))
    async def process_start_command(message: Message):
        keyboard: list[list[InlineKeyboardButton]] = [
            [InlineKeyboardButton(text='Хочу еще!', callback_data='more')]]
        markup: InlineKeyboardMarkup = InlineKeyboardMarkup(
            inline_keyboard=keyboard)
        await message.answer(
            text=jokes[random_joke()],
            reply_markup=markup)
    
    
    # Этот хэндлер будет срабатывать на нажатие кнопки "Хочу еще!"
    @dp.callback_query(Text(text='more'))
    async def process_more_press(callback: CallbackQuery):
        keyboard: list[list[InlineKeyboardButton]] = [
            [InlineKeyboardButton(text='Хочу еще!', callback_data='more')]]
        markup: InlineKeyboardMarkup = InlineKeyboardMarkup(
            inline_keyboard=keyboard)
        # Отвечаем на callback, чтобы убрать часики
        await callback.answer()
        # Отправляем в чат новое сообщение с шуткой
        await callback.message.answer(
            text=jokes[random_joke()],
            reply_markup=markup)
    
    
    # Этот хэндлер будет срабатывать на любые сообщения, кроме команд
    @dp.message()
    async def send_echo(message: Message):
        await message.answer(
            text='Я даже представить себе не могу, '
                 'что ты имеешь в виду :(\n\n'
                 'Чтобы получить какую-нибудь шутку - '
                 'отправь команду /joke')
    
    
    # Запускаем поллинг
    if __name__ == '__main__':
        dp.run_polling(bot)

### ![](https://ucarecdn.com/06f4f9c2-3d96-498a-92b7-8e83c89d8490/)

### Способ 2. Отправка нового сообщения с удалением старого

А теперь чуть-чуть изменим код этого бота. Теперь старое сообщение с кнопкой будет удаляться и приходить новое. Для этого нужно изменить всего одну строчку (точнее 2, если комментарий тоже считать) в хэндлере `process_more_press`. Вместо

    # Отвечаем на callback, чтобы убрать часики
    await callback.answer()

Надо вставить

    # Удаляем сообщение, в котором была нажата кнопка
    await callback.message.delete()

Запустите бота и посмотрите как сейчас ведет себя телеграм-клиент.

![](https://ucarecdn.com/e41d906a-5d42-4dda-ba0b-8926545a81cd/)

### Способ 3. Редактирование сообщения

Данный способ, на мой взгляд, самый удачный. Нет ненужного отвлекающего мельтешения сообщений. Cнова надо совсем чуть-чуть изменить хэндлер `process_more_press`. Теперь он будет выглядеть вот так:

    # Этот хэндлер будет срабатывать на нажатие кнопки "Хочу еще!"
    @dp.callback_query(Text(text='more'))
    async def process_more_press(callback: CallbackQuery):
        keyboard: list[list[InlineKeyboardButton]] = [
            [InlineKeyboardButton(text='Хочу еще!', callback_data='more')]]
        markup: InlineKeyboardMarkup = InlineKeyboardMarkup(
            inline_keyboard=keyboard)
        # Редактируем сообщение
        await callback.message.edit_text(
            text=jokes[random_joke()],
            reply_markup=markup)

Мы просто теперь используем метод `edit_text` у поля `message` объекта `callback`. Запустите бота с этими изменениями и посмотрите, как теперь отрабатывается нажатие на инлайн-кнопку.

![](https://ucarecdn.com/cd8ddab8-e874-4b2d-8aa9-84a4d19b7630/)

Обратили внимание, что в один момент бот перестал на какое-то время реагировать на нажатие кнопки? Мы уже сталкивались с такой ситуацией, когда учились работать с инлайн-кнопками. Так как числа - ключи шуток из словаря `jokes` в нашем примере, генерируются случайным образом - иногда функция `randome_joke` выдает подряд один и тот же результат. Телеграм понимает, что при редактировании сообщения мы отправляем ему то же самое, то есть в редактируемом сообщении ничего не меняется, и генерирует исключение вида

    Telegram server says Bad Request: message is not modified: specified new message content and reply markup are exactly the same as a current content and reply markup of the message

На следующем шаге подробно разберемся как с этим жить :)