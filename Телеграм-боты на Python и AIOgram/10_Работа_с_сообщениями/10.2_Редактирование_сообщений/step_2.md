## Исключение TelegramBadRequest (message is not modified)
-------------------------------------------------------

Сам принцип редактирования текстовых сообщений (с клавиатурой или без) очень простой. У таких апдейтов есть поле `message`, к которому можно применить метод `edit_text`. Я об этом уже говорил на предыдущем шаге и еще в предыдущих уроках. У такого сообщения можно изменить либо текст, либо клавиатуру, либо и то и другое сразу. Самый неочевидный нюанс, с которым часто сталкиваешься в начале пути разработки ботов - это сообщение в терминале `message is not modified`, сообщающее о том, что была попытка отправить в чат сообщение, которое в точности повторяет то, которое нужно отредактировать.

Если вы, в процессе написания кода, понимаете, что можете столкнуться с таким исключением, то можете пойти по одному из следующих путей:

1.  Сравнивать текст, который вы хотите отправить с тем, который вы хотите отредактировать. Если они совпадают, то не отправлять новый текст.
2.  Перехватывать исключение конструкцией `try/except`. Имеет смысл, если ситуация потенциально может возникать достаточно редко, а иначе отправка немодифицированных сообщений увеличивает нагрузку на Telegram Bot API и будет снижать производительность вашего кода из-за относительно медленно работающей конструкции `try/except`.
3.  Можно гарантированно менять сообщение перед отправкой.

Давайте возьмем бота из предыдущего шага и либо избавимся от ошибки, либо проигнорируем ее.

Сначала избавимся. Немного порассуждаем. У нас есть сообщение с шуткой и инлайн-кнопкой.

![](https://ucarecdn.com/296fe973-c99d-43ed-a002-8f9f268f8dce/-/preview/-/enhance/79/)

При нажатии на инлайн-кнопку срабатывает хэндлер `process_more_press`, принимающий в качестве параметра объект типа `CallbackQuery`, в котором, помимо прочего, есть весь текст сообщения вместе с клавиатурой (поля "text" и "inline\_markup"), кнопка под которым была нажата пользователем, а также коллбэкдата (поле "data") нажатия на эту кнопку.

    {
      "id": "746901999347209228",
      "from": {
        "id": 173901673,
        "is_bot": false,
        "first_name": "Mikhail",
        "last_name": "Kryzhanovskiy",
        "username": "kmsint",
        "language_code": "ru"
      },
      "message": {
        "message_id": 5328,
        "from": {
          "id": 5424991242,
          "is_bot": true,
          "first_name": "New_name",
          "username": "VeryVeryVerySmart_bot"
        },
        "chat": {
          "id": 173901673,
          "first_name": "Mikhail",
          "last_name": "Kryzhanovskiy",
          "username": "kmsint",
          "type": "private"
        },
        "date": 1674061106,
        "edit_date": 1674068066,
        "text": "у меня на балконе сосулька растет метровая, прямо над машиной, которая ссигналит каждую ночь. Я эту сосульку из распылителя подкармливаю.",
        "reply_markup": {
          "inline_keyboard": [
            [
              {
                "text": "Хочу еще!",
                "callback_data": "more"
              }
            ]
          ]
        }
      },
      "chat_instance": "6282145159071621880",
      "data": "more"
    }

Мы точно знаем, что кнопка у нас одна и ее редактировать мы не планируем. Мы хотим отредактировать только текст шутки. Тогда нам просто достаточно сравнить текст, хранящийся в объекте типа `CallbackQuery` с текстом, который мы хотим отправить методом `edit_text`. Если совпадает - генерируем номер шутки еще раз. Если не совпадает - отправляем новую шутку через редактирование сообщения. Вот так, например, это можно сделать:

    # Этот хэндлер будет срабатывать на нажатие кнопки "Хочу еще!"
    async def process_more_press(callback: CallbackQuery):
        keyboard: list[list[InlineKeyboardButton]] = [
            [InlineKeyboardButton(text='Хочу еще!', callback_data='more')]]
        markup: InlineKeyboardMarkup = InlineKeyboardMarkup(
            inline_keyboard=keyboard)
        # Получаем текст шутки по ключу, сгенерированному функцией
        # random_joke и сохраняем в переменную text
        text = jokes[random_joke()]
        # Пока текст новой шутки совпадает со старым -
        # генерируем новую шутку
        while text == callback.message.text:
            text = jokes[random_joke()]
        # Редактируем сообщение гарантированно отличающимся текстом
        await callback.message.edit_text(
                                text=text,
                                reply_markup=markup)

Так можно избавиться от потенциально возможного исключения `Telegram server says Bad Request: message is not modified: specified new message content and reply markup are exactly the same as a current content and reply markup of the message` еще на этапе формирования нового сообщения, на которое будет заменено старое.

А теперь давайте попробуем проигнорировать исключение.

### Игнорируем исключение с помощью try/except

Перепишем хэндлер `process_more_press`, обернув в `try/except` редактирование сообщения. При этом нужно из `aiogram.exceptions` не забыть импортировать объект `TelegramBadRequest`.

    from aiogram.exceptions import TelegramBadRequest
    
    # ...
    
    # Этот хэндлер будет срабатывать на нажатие кнопки "Хочу еще!"
    async def process_more_press(callback: CallbackQuery):
        keyboard: list[list[InlineKeyboardButton]] = [
            [InlineKeyboardButton(text='Хочу еще!', callback_data='more')]]
        markup: InlineKeyboardMarkup = InlineKeyboardMarkup(
            inline_keyboard=keyboard)
        # Пытаемся отредактировать сообщение
        try:
            await callback.message.edit_text(
                text=jokes[random_joke()],
                reply_markup=markup)
        except TelegramBadRequest:
            # В случае возникновения исключения - игнорируем его,
            # отвечая на коллбэк пустым ответом
            await callback.answer()

Можете убедиться в том, что бот теперь не зависает надолго и почти сразу убирает часики, даже если само сообщение не изменилось.

Основной недостаток методов, при которых мы игнорируем исключение `TelegramBadRequest`, состоит в том, что пользователь не получает обновленного сообщения. На кнопку, вроде, нажал, но сообщение почему-то не поменялось, хотя и часики, вроде пропали. Поэтому, в большинстве случаев, имеет смысл все-таки проверять на совпадение старого и нового сообщения перед вызовом метода `edit_text`.