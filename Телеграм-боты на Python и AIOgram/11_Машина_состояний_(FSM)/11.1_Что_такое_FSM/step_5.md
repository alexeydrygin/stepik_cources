## Общий алгоритм работы с состояниями
-----------------------------------

Давайте для закрепления еще раз пройдемся по алгоритму работы с машиной состояний в `aiogram`.

1.  Из `aiogram.filters` импортируем `StateFilter` - класс, облегчающий работу с фильтрами состояний
    
        from aiogram.filters import StateFilter
    
2.  Из `aiogram.filters.state` импортируем классы `State` и `StatesGroup`
    
        from aiogram.filters.state import State, StatesGroup
    
    Класс `State` отвечает за конкретное состояние пользователя в конкретный момент времени, а `StatesGroup` за группу состояний, связанных по смыслу.
    
3.  Из `aiogram.fsm.context` импортируем класс `FSMContext`
    
        from aiogram.fsm.context import FSMContext
    
    Через этот класс можно в хэндлеры передавать данные о состоянии пользователя, а также дополнительные данные пользователя, имеющиеся в хранилище (например, ответы, которые пользователь отправлял боту в разных состояниях)
    
4.  Из `aiogram.fsm.storage` импортируем класс хранилища. Если это `MemoryStorage`, как в предыдущем примере, то импорт такой:
    
        from aiogram.fsm.storage.memory import MemoryStorage
    
    Если в качестве хранилища предполагается использовать, например, **Redis**, которому, применительно к FSM, посвящен следующий урок, тогда импорт такой:
    
        from aiogram.fsm.storage.redis import RedisStorage
    
5.  Создаем объект хранилища, как экземпляр класса импортированного хранилища. Например, для хранилища `MemoryStorage` так:
    
        storage: MemoryStorage = MemoryStorage()
    
6.  При инициализации диспетчера, передаем в качестве параметра `storage` объект хранилища:
    
        dp: Dispatcher = Dispatcher(storage=storage)
    
7.  Создаем класс, наследуемый от `StatesGroup`, название которого может быть любым, но желательно, чтобы оно начиналось с "FSM", чтобы было понятно, что данный класс относится к машине состояний. Таких классов может быть несколько, если подразумевается несколько групп состояний. Например, одна группа состояний будет отвечать за то, чтобы пользователь заполнил информацию о себе, вторая группа будет отвечать за кастомизацию настроек бота, третья за работу с какими-нибудь платными подписками, четвертая за какой-нибудь демонстрационный диалог, чтобы обучить пользователя эффективнее взаимодействовать с ботом и так далее.
    
        class FSMFillForm(StatesGroup):
        
        # ...
    
8.  Внутри этого класса последовательно создаем экземпляры класса `State`, отвечающие за состояния, относящиеся к данной группе и, желательно, идущие по порядку в той же последовательности, в какой планируется переход между ними в боте при штатной работе.
    
        class FSMFillForm(StatesGroup):
        
            # ...
        
            fill_name = State()        # Состояние ожидания ввода имени
            fill_age = State()         # Состояние ожидания ввода возраста
            fill_gender = State()      # Состояние ожидания выбора пола
            upload_photo = State()     # Состояние ожидания загрузки фото
            fill_education = State()   # Состояние ожидания выбора образования
            fill_wish_news = State()   # Состояние ожидания выбора получать ли новости
        
            # ...
    
9.  При наступлении определенных событий (например, пользователь отправляет в чат с ботом команду, подразумевающую переход в машину состояний) в хэндлере устанавливается соответствующее состояние соответствующей группы.
    
        # ...
        
        await state.set_state(FSMFillForm.fill_name)
        
        # ...
    
10.  Создается обработчик или обработчики для данного состояния, в которые может, в качестве параметра, передаваться аргумент типа `FSMContext`, содержащий информацию о пользователе, его состоянии и данных, полученных от пользователя внутри состояний. Внутри обработчика данные из апдейта могут быть сохранены в объекте типа `FSMContext`, чтобы быть доступными в других хэндлерах, в других состояниях. Также в хэндлере может быть осуществлена установка другого состояния, согласно логике бота.
    
        async def <какой-то_хэндлер>(message: Message, state: FSMContext):
            
            # ...
        
            await state.update_data(<какой-то_ключ>=message.text)
        
            # ...
        
            await state.set_state(FSMFillForm.fill_age)
    
11.  Если пользователь пожелал выйти из машины состояний, совершив какое-либо действие отмены (отправил команду /cancel или нажал на инлайн-кнопку "Отменить" и т.п.) - сбрасываем текущее состояние либо с сохранением данных - `await state.set_state(state=None)`, либо без сохранения `await state.clear()`
    
        async def process_cancel_command(message: Message, state: FSMContext):
            # ...
            
            await state.clear()
        
            # ...
    
12.  Если пользователь прошел по всем состояниям и нужно завершить машину состояний - сохраняем данные, полученные от пользователя внутри состояний (если это требуется). Получить эти данные можно с помощью метода `get_data()` у объекта типа `FSMContext`.
13.  Завершаем работу с машиной состояний методом `clear()` у объекта типа `FSMContext`.