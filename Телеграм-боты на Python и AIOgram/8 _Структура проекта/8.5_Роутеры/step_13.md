## Некоторые особенности роутеров
------------------------------

Как я уже говорил, в рамках работы с роутерами есть один очень удобный момент, заключающийся в том, что на роутеры можно вешать фильтры (еще и миддлвари, но про них отдельно).

Для того, чтобы апдейт попытался пройти фильтры хэндлеров, зарегистрированных в этом роутере, ему сначала нужно будет пройти фильтры самого роутера. Тем самым появляются возможности более тонкой настройки поведения бота с одной стороны, и уменьшается количество тупого копипаста с другой.

То есть, если мы хотим сделать несколько хэндлеров, которые будут доступны какой-нибудь группе пользователей, например, тем, кто оплатил подписку, нам не надо будет на каждый хэндлер вешать фильтр проверки апдейта на принадлежность пользователю из группы, нам достаточно будет повесить этот фильтр на роутер, в котором мы регистрируем эти хэндлеры.

**Пример.** Допустим мы хотим создать группу хэндлеров, которые будут срабатывать только если пользователи уже есть в нашей базе данных. Пусть мы для этого создали соответствующий фильтр `KnownUser`. Если не использовать возможность закрепить фильтр за роутером, который будет отвечать за эту группу хэндлеров, то придется в каждом хэндлере дополнительно прописывать этот фильтр.

    @router.message(filter_1, filter_2, KnownUser())
    async def handler_1(message: Message):
        # ...
    
    
    @router.message(filter_3, KnownUser())
    async def handler_2(message: Message):
        # ...
    
    
    @router.message(filter_4, filter_5, KnownUser())
    async def handler_3(message: Message):
        # ...
    
    
    @router.message(filter_6, KnownUser())
    async def handler_4(message: Message):
        # ...

Также в случае, если по какой-то причине, фильтр понадобится убрать из хэндлеров - придется удалять его из каждого хэндлера. Но если же указать фильтр для роутера, то сделать это надо всего один раз, а работать он будет для всех хэндлеров группы. Чистота и понятность кода повышается, а количество повторяющихся действий сокращается.

    router.message.filter(KnownUser())
    
    
    @router.message(filter_1, filter_2)
    async def handler_1(message: Message):
        # ...
    
    
    @router.message(filter_3)
    async def handler_2(message: Message):
        # ...
    
    
    @router.message(filter_4, filter_5)
    async def handler_3(message: Message):
        # ...
    
    
    @router.message(filter_6)
    async def handler_4(message: Message):
        # ...

Становится еще проще изолировать разные слои бота друг от друга. Главное, правда, не переусердствовать :)

Еще один момент. Так же как важен порядок расположения хэндлеров по коду, так же важен и порядок регистрации роутеров в диспетчере, потому что если еще раз посмотреть на картинку из документации к `aiogram` - можно понять, что если порядок будет нарушен - апдейты могут быть перехвачены не теми хэндлерами, которые для них предназначены.

![](https://ucarecdn.com/faed387a-915e-41b2-952f-718fa424fefa/-/preview/-/enhance/83/)

В следующем модуле мы будем писать ботов немного сложнее, чем эхо-бот, также используя модульную структуру, и вы еще лучше сможете разобраться с тем, как роутеры работают.