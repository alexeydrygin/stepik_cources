## Диспетчер - корневой роутер
---------------------------

Я уже неоднократно упоминал как, в целом, работает `aiogram`. В его основе диспетчер, который распределяет апдейты, полученные с серверов телеграм, по хэндлерам. То есть пришел какой-то апдейт (пользователь отправил боту команду /help, например), в диспетчере зарегистрирваны все хэндлеры в определенном порядке с фильтрами. Диспетчер "пробегает" по всем хэндлерам и через фильтры пытается передать апдейт каждому хэндлеру по очереди. Как только фильтры пройдены - происходит вызов соответствующего хэндлера. Диспетчер берет следущий апдейт и опять пытается его передать какому-нибудь хэндлеру. Если цепочка хэндлеров закончилась, а апдейт так никому и не передан, апдейт растворяется в небытии :) И так по кругу. Сейчас я намеренно опускаю слой миддлварей, чтобы не усложнять. Пока, для выстраивания более менее общей картины, нам достаточно диспетчера, фильтров и хэндлеров.

Если посмотреть на исходники `aiogram`, а именно на класс `Dispatcher`, то увидим следующее:

    class Dispatcher(Router):
        """
        Root router
        """
    
        def __init__(
            self,
            *,  # * - Preventing to pass instance of Bot to the FSM storage
            storage: Optional[BaseStorage] = None,
            fsm_strategy: FSMStrategy = FSMStrategy.USER_IN_CHAT,
            events_isolation: Optional[BaseEventIsolation] = None,
            disable_fsm: bool = False,
            name: Optional[str] = None,
            **kwargs: Any,
        ) -> None:
            """
            Root router
    
            :param storage: Storage for FSM
            :param fsm_strategy: FSM strategy
            :param events_isolation: Events isolation
            :param disable_fsm: Disable FSM, note that if you disable FSM
                then you should not use storage and events isolation
            :param kwargs: Other arguments, will be passed as keyword arguments to handlers
            """
    
        # ...

Во-первых, `Dispatcher` наследуется от класса `Router`, а во-вторых, в докстринге явно написано `"""Root router"""`. То есть, получается, что диспетчер - это некий корневой роутер, а если есть корень, значит должны быть ветки и листья, так? Ну, да, типа того :)

Но мы ведь с вами как-то обходились только "корнем" до этого момента. Зачем нам, вдруг, ветки понадобились?

Нам хватало диспетчера, потому что каждый предыдущий бот состоял всего из одного модуля и диспетчер был внутри него доступен при декорировании хэндлеров. Но так как мы с вами условились разделять проект на модули и пакеты - диспетчер будет только в области видимости того модуля, где он проинициализирован, то есть внутри точки входа **bot.py**. А если мы попытаемся его из точки входа импортировать - получим либо циклический импорт, либо какое-то другое неожиданное поведение.

Давайте убедимся в этом на практике, чтобы вы, так сказать, руками пощупали проблему перед тем, как ее решать. Заодно начнем осваивать шаблон, а также заземлим теорию из [урока](https://stepik.org/lesson/759401/step/1?unit=761417) про модули и пакеты.