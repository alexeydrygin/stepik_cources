## Избегайте циклических импортов
------------------------------

Прежде, чем я хорошо разобрался с тем, как работают импорты, я часто сталкивался с ошибкой циклических импортов. Это когда вы импортируете что-то в один модуль, назовем его, например, `mod_1.py` из другого, назовем его `mod_2.py`, а потом дальше по коду проекта, импортируете что-то из модуля `mod_1.py` в `mod_2.py`. Причем, не обязательно напрямую, это может быть импорт через несколько других модулей.

Чтобы избегать циклических импортов, самая действенная рекомендация, которую я могу дать из своего опыта, - мысленно представляйте, что вы пишете весь код проекта в одном файле и при каждом импорте последовательно исполняется весь код модуля, который вы импортируете.

Давайте покажу на примере. Пусть у нас есть три модуля, находящихся в одной директории - `main.py`, `mod_1.py` и `mod_2.py`. 

### main.py

    from mod_1 import func_1
    
    
    print(func_1(3))

### mod\_1.py

    from mod_2 import func_2
    
    
    def func_1(n: int) -> int:
        return n * n
    
    
    user: dict[str, str] = {'username': 'kmsint',
                            'name': 'Mikhail',
                            'status': 'new'}
    
    
    print(func_2(4))

### mod\_2.py

    from mod_1 import user
    
    
    def func_2(n: int) -> int:
        return n + n
    
    
    print(user)

Мы хотим в основном исполняемом файле `main.py` выполнить функцию из модуля `mod_1.py`. При этом в модуль `mod_1.py` происходит импорт функции `func_2` из модуля `mod_2.py`, а в модуле `mod_2.py` происходит импорт переменной `user` из модуля `mod_1.py`. Если запустить файл `main.py`, результатом в терминале будет ошибка. Там ее длинное описание, но суть в последнем сообщении:

    from mod_1 import user
    ImportError: cannot import name 'user' from partially initialized module 'mod_1' (most likely due to a circular import)

Циклический импорт. Если попытаться последовательно представить работу кода - получится следующее. Сначала идет попытка импорта функции `func_1` из модуля `mod_1.py`, а мы с вами знаем, что при импорте код модуля выполняется полностью. Соответственно, переходим к выполнению кода из модуля `mod_1.py`. Видим там первую инструкцию по импорту функции `func_2` из модуля `mod_2.py`. Интерпретатор пытается ее выполнить и вдруг обнаруживает в модуле `mod_2` попытку импортировать переменную `user` из модуля `mod_1.py`. А ведь модуль `mod_1.py` уже частично закэширован интерпретатором, то есть интерпретатор понимает, что попытка импорта модуля уже была, но не была закончена, потому что была инструкция импортировать что-то из модуля `mod_2.py`, который пытается что-то импортировать из модуля `mod_1.py`. Произошло зацикливание и интерпретатор сказал - ну его нафиг, разберитесь сначала с этими вашими импортами, я не буду.

Конечно, этот пример кажется надуманным и, вроде, здесь очевидно, почему не будет нормально работать, но поверьте мне, в больших проектах сталкиваешься с циклическими импортами довольно часто и принцип их появления один и тот же. Когда я встречаюсь с такой проблемой - беру листок, ручку и начинаю рисовать как работает проект - как последовательно выполняются инструкции. Иногда это занимает немало времени, но дает очень глубокое понимание работы проекта, которое, в дальнейшем, сильно упрощает жизнь при взаимодействии с ним.

А при проектировании чего-то нового - бота или любого другого сервиса, - важно простраивать связи между модулями и пакетами. Можно на бумаге, можно в каком-нибудь графическом редакторе - многое будет сразу видно и многих проблем можно будет избежать.