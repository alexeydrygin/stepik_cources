## Модули

---

Модулями в Python называются отдельные файлы с кодом. Среди python-разработчиков есть договоренность называть модули в стиле snake\_case (это когда все маленькими буквами, а разделители между словами - подчеркиваниями). Пакеты, кстати, тоже. Но сначала все-таки про модули.

Давайте представим, что у нас есть основной исполняемый файл - точка входа в программу, и несколько вспомогательных файлов с функциями, классами, данными. Существует три способа добавить код из этих файлов в исполняемый файл, с использованием команды `import`. Для простоты примера пусть у нас будет основной файл `main.py`, файл с функциями `functions.py`, файл с классами `classes.py`, и файл с данными `data.py`. Тут важно иметь в виду, что для того, чтобы код ниже корректно работал все файлы должны находиться в одной директории.

### functions.py

    print('Это модуль functions')
    
    
    def get_double_number(number: int) -> int:
        return number * 2

### data.py

    print('Это модуль data')
    
    my_dict: dict[int, str] = {1: 'One',
                               2: 'Two',
                               3: 'Three'}

### classes.py

    print('Это модуль classes')
    
    
    class MyClass:
        def __init__(self) -> None:
            print('Это класс MyClass')

### main.py

    import functions
    from data import my_dict
    from classes import *
    
    
    print('Это исполняемый файл')
    
    
    if __name__ == '__main__':
        print('Код ниже не выполнится, если этот файл будет импортируемым модулем в другой исполняемый файл')
        print(functions.get_double_number(100))
        print(my_dict)
        MyClass()

Если теперь запустить файл `main.py`, то в консоли мы увидим следующее:

    Это модуль functions
    Это модуль data
    Это модуль classes
    Это исполняемый файл
    Код ниже не выполнится, если этот файл будет импортируемым модулем в другой исполняемый файл
    200
    {1: 'One', 2: 'Two', 3: 'Three'}
    Это класс MyClass

То есть при импорте получается, что интерпретатор Python исполняет импортируемые модули. Причем последовательно, именно в том порядке как они импортируются. То есть если весь код, разбитый по модулям, представить в виде одного файла, то получится следующее:

    print('Это модуль functions')
    
    
    def get_double_number(number: int) -> int:
        return number * 2
    
    
    print('Это модуль data')
    
    my_dict: dict[int, str] = {1: 'One',
                               2: 'Two',
                               3: 'Three'}
    
    
    print('Это модуль classes')
    
    
    class MyClass:
        def __init__(self) -> None:
            print('Это класс MyClass')
    
    
    print('Это исполняемый файл')
    
    
    if __name__ == '__main__':
        print('Код ниже не выполнится, если этот файл будет импортируемым модулем в другой исполняемый файл')
        print(get_double_number(100))
        print(my_dict)
        MyClass()

Обратите внимание на строчку `print(get_double_number(100))`. Она изменилась. Теперь функция вызывается напрямую, без указания модуля, в котором она изначально была. Потому что она объявлена ни где-то в другом модуле, а прямо в исполняемом файле.

Давайте вернемся к первоначальному разделению на модули и проведем небольшой эксперимент, который еще лучше поможет понять как работают модули. Т.к. код модулей исполняется интерпретатором Python, то если мы в один из модулей добавим бесконечный цикл, то программа зависнет, так? Давайте проверим. Добавим такой цикл, например, в модуль `data.py`:

    print('Это модуль data')
    
    
    while True:
        pass
    
    
    my_dict: dict[int, str] = {1: 'One',
                               2: 'Two',
                               3: 'Three'}

И запустим `main.py`. В консоли увидим следующее:

    Это модуль functions
    Это модуль data
    _

Программа зависла, а значит, мы точно убедились в том, что код каждого модуля исполняется, даже если мы из модуля импортируем всего один объект. Но способы импортов влияют на пространство имен объектов, которые хранит интерпретатор в ходе исполнения нашей программы. 

Пространство имен на каждом этапе можно посмотреть, если вызвать встроенную функцию `dir`. Давайте уберем бесконечный цикл из модуля `data` и добавим пару строк в исполняемый файл `main`.

### main.py

    print(dir())
    
    import functions
    from data import my_dict
    from classes import *
    
    
    print('Это исполняемый файл')
    
    new_variable: int = 15
    
    
    if __name__ == '__main__':
        print('Код ниже не выполнится, если этот файл будет импортируемым модулем в другой исполняемый файл')
        print(functions.get_double_number(100))
        print(my_dict)
        MyClass()
        print(dir())

Запустим `main.py` и посмотрим на пространства имен до импортов и в самом конце программы.

    ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
    Это модуль functions
    Это модуль data
    Это модуль classes
    Это исполняемый файл
    Код ниже не выполнится, если этот файл будет импортируемым модулем в другой исполняемый файл
    200
    {1: 'One', 2: 'Two', 3: 'Three'}
    Это класс MyClass
    ['MyClass', '__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'functions', 'my_dict', 'new_variable']

Смотрите, если сравнить списки из начала и конца вывода в консоль, можно увидеть, что к именам на самом старте программы добавились имена модулей и объектов из модулей, которые мы импортировали, а также создавали в самом исполняемом файле. Это, например, может дать понять почему, не смотря на то, что модуль исполняется полностью, одни объекты из него остаются доступными, а другие нет. Сейчас покажу. 

В файле `main.py` мы писали `import functions` и у нас доступен объект `functions`, как мы можем убедиться, еще раз взглянув на список имен в консоли. А у объекта `functions`, соответственно, доступны свои имена. Добавим в файл `main.py` последней строчкой `print(dir(functions))` и убедимся в этом, запустив программу. В консоли последней строкой получим список:

    ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'get_double_number']

Смотрите, среди встроенных имен объекта `functions` также есть и наша функция `get_double_number`.

А теперь давайте в файле `main.py` заменим строку `import functions` на `from functions import get_double_number`, а строку `print(dir(functions))` уберем. Теперь мы можем обращаться к функции `get_double_number` напрямую, поэтому надо еще заменить строку `print(functions.get_double_number(100))` на `print(get_double_number(100))`. Снова посмотрим на пространство имен в конце исполнения программы:

    ['MyClass', '__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'get_double_number', 'my_dict', 'new_variable']

Теперь в пространстве имен нет объекта `functions`, но есть объект `get_double_number`.

В общем, всеми этими экспериментами я хотел показать, что подключаемые модули читаются и исполняются полностью, но, в зависимости от того, как именно мы их подключаем, меняется пространство имен, доступное интерпретатору в ходе выполнения программы. Ну, и еще раз для лучшего запоминания. Строчка

    import functions

Исполняет модуль functions и сохраняет все объекты, объявленные в этом модуле, доступными для вызова. Правда, обращаться к ним можно не напрямую, а через точечную нотацию, то есть, чтобы выполнить функцию `get_double_number`, к ней нужно обратиться так:

    functions.get_double_number(100)

Если же мы запишем строку

    from functions import get_double_number

то в ходе программы можно будет вызывать функцию так:

    get_double_number(100)

Кстати, импортируемым объектам Python позволяет присваивать алиасы (псевдонимы), то есть, например, можно импортировать модуль `functions`, задав ему псевдоним `f`. Делается это так:

    import functions as f

и тогда вызвать функцию `get_double_number`, можно так:

    f.get_double_number(100)

И еще один способ импорта модуля.

    from functions import *

Эта инструкция позволяет загрузить из модуля `functions` все объекты, которые в нем объявлены (за некоторыми исключениями, о которых чуть дальше), но ее обычно не рекомендуют использовать, потому что в пространство имен "вываливаются" все объекты модуля, а если модуль большой с кучей объектов, можно запутаться в коде. Читабельность сильно снижается. Обычно, чтобы понять откуда в коде взялся тот или иной объект - надо посмотреть на импорты, которые принято располагать в самом начале файла, и на сам код, а в случае со звездочкой быстрого ответа можно не получить.