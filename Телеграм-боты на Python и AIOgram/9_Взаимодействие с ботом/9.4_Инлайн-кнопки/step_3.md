## Callback-кнопки
---------------

Данный вид кнопок - это, наверное, самый часто используемый вид инлайн-кнопок в телеграм-ботах, который очень сильно расширяет возможности мессенджера. Суть их работы сводится к тому, что при нажатии на такую кнопку приходит апдейт, в котором есть параметр `data`. На апдейты с такими параметрами можно настроить отдельные хэндлеры, которые будут запускать буквально любые сценарии. Давайте покажу на простом примере.

Пусть у нас по команде /start в чат пользователю отправляется сообщение с двумя инлайн-кнопками и параметрами `callback_data` равными `'big_button_1_pressed'` и `'big_button_2_pressed'`.

    from aiogram import Bot, Dispatcher
    from aiogram.filters import CommandStart
    from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message
    
    # Вместо BOT TOKEN HERE нужно вставить токен вашего бота,
    # полученный у @BotFather
    API_TOKEN: str = 'BOT TOKEN HERE'
    
    # Создаем объекты бота и диспетчера
    bot: Bot = Bot(token=API_TOKEN)
    dp: Dispatcher = Dispatcher()
    
    # Создаем объекты инлайн-кнопок
    big_button_1: InlineKeyboardButton = InlineKeyboardButton(
        text='БОЛЬШАЯ КНОПКА 1',
        callback_data='big_button_1_pressed')
    
    big_button_2: InlineKeyboardButton = InlineKeyboardButton(
        text='БОЛЬШАЯ КНОПКА 2',
        callback_data='big_button_2_pressed')
    
    # Создаем объект инлайн-клавиатуры
    keyboard: InlineKeyboardMarkup = InlineKeyboardMarkup(
        inline_keyboard=[[big_button_1],
                         [big_button_2]])
    
    
    # Этот хэндлер будет срабатывать на команду "/start"
    # и отправлять в чат клавиатуру с инлайн-кнопками
    @dp.message(CommandStart())
    async def process_start_command(message: Message):
        await message.answer(text='Это инлайн-кнопки. Нажми на любую!',
                             reply_markup=keyboard)
    
    
    if __name__ == '__main__':
        dp.run_polling(bot)

![](https://ucarecdn.com/5e3ce2f2-78b2-40d6-a457-4df2c5d5cc7f/-/preview/-/enhance/78/)

Давайте посмотрим на структуру апдейта, который приходит на сервера телеграм, после нажатия на такую кнопку.

    {
      "ok": true,
      "result": [
        {
          "update_id": 396711520,
          "callback_query": {
            "id": "746902002177162726",
            "from": {
              "id": 173901673,
              "is_bot": false,
              "first_name": "Mikhail",
              "last_name": "Kryzhanovskiy",
              "username": "kmsint",
              "language_code": "ru"
            },
            "message": {
              "message_id": 3385,
              "from": {
                "id": 5424991242,
                "is_bot": true,
                "first_name": "New_name",
                "username": "VeryVeryVerySmart_bot"
              },
              "chat": {
                "id": 173901673,
                "first_name": "Mikhail",
                "last_name": "Kryzhanovskiy",
                "username": "kmsint",
                "type": "private"
              },
              "date": 1670598762,
              "text": "Это инлайн-кнопки. Нажми на любую!",
              "reply_markup": {
                "inline_keyboard": [
                  [
                    {
                      "text": "БОЛЬШАЯ КНОПКА 1",
                      "callback_data": "big_button_1_pressed"
                    }
                  ],
                  [
                    {
                      "text": "БОЛЬШАЯ КНОПКА 2",
                      "callback_data": "big_button_2_pressed"
                    }
                  ]
                ]
              }
            },
            "chat_instance": "6282145159071621880",
            "data": "big_button_2_pressed"
          }
        }
      ]
    }

Во-первых, тип апдейта - `callback_query`, в котором целиком содержится сообщение вместе с клавиатурой, кнопка на которой была нажата. Это параметры `"text"` и `"reply_markup"`, то есть мы сможем использовать эти данные для понимания в каком именно сообщении была нажата кнопка, а также для изменения этого сообщения в чате с пользователем, если будет необходимость. А во-вторых, самое важное, - апдейт содержит поле `"data"`, совпадающее по своему значению со значением `"callback_data"` нажатой кнопки. Именно по значению `"data"` мы и определяем какая именно кнопка была нажата пользователем. Вот эту самую `"data"` мы и будем ловить хэндлерами, срабатывающими на нажатие кнопок.

Сейчас в нашем мини-боте, из примера выше, нету хэндлеров, обрабатывающих нажатия на кнопки и, поэтому, если нажать на кнопку, можно увидеть "часики", как-будто бот задумался.

![](https://ucarecdn.com/eb5f9c68-bf7a-4d5a-9818-dd041cfdefe2/-/preview/-/enhance/79/)

Часики улучшают юзер экспириенс, показывая пользователю, что боту нужно время для выполнения какого-то действия, тем более, что действие, за нажатием на такую кнопку, как я уже говорил выше, может скрываться совершенно любое. Но в данном случае, часики показывают как-раз то, что ничего не происходит, потому что мы никак не обрабатываем такое нажатие. Такие часики крутятся около 20 секунд, а потом пропадают. Давайте научимся их убирать.

Т.к. тип апдейта с нажатием на инлайн-кнопку с `callback_data` - это `СallbackQuery`, то, само собой, как мы уже привыкли, в `aiogram.types` есть такой класс. Он нам и понадобится при отлавливании апдейтов такого типа. Весь код бота, который уже есть выше, приводить не буду, приведу только хэндлер, срабатывающий на нажатие обеих кнопок и отправляющих пустой ответ, чтобы убрать часики с кнопки. Также в диспетчере нам понадобится новый метод - `callback_query`, чтобы зарегистрировать хэндлер, обрабатывающий апдейт типа `CallbackQuery`. Ну, и импорт этого класса, конечно, надо не забыть. А еще, чтобы отфильтровать `callback_data` - будем пользоваться уже известным нам фильтром `Text`. Да, этот фильтр прекрасно работает не только для поля `"text"` апдейта типа `Message`, но и на поле `"data"` апдейта типа `CallbackQuery`.

    from aiogram.filters import Text
    from aiogram.types import CallbackQuery
    
    # ...
    
    # Этот хэндлер будет срабатывать на апдейт типа CallbackQuery
    # с data 'big_button_1_pressed' или 'big_button_2_pressed'
    @dp.callback_query(Text(text=['big_button_1_pressed',
                                  'big_button_2_pressed']))
    async def process_buttons_press(callback: CallbackQuery):
        await callback.answer()
    
    # ...

Считается хорошим тоном отвечать на каждое нажатие callback-кнопки, чтобы бот не "зависал в задумчивости". Для этого, как в нашем примере, достаточно в конце хэндлера отправлять `callback.answer()`, даже если никаких реакций на нажатие кнопки не предполагается.

Для регистрации хэндлеров, принимающих на вход `CallbackQuery`, у диспетчера (роутеров) есть метод `callback_query`, которым и надо пользоваться для обработки апдейтов этого типа. В этом примере, с помощью фильтра `Text` происходит полная проверка на совпадение  `callback.data` с одним из элементов списка `['big_button_1_pressed', 'big_button_2_pressed']`.

Если запустить теперь нашего мини-бота, то можно убедиться, что часики пропадают почти сразу после того, как мы нажимаем на кнопку.

![](https://ucarecdn.com/d1695373-0766-4de5-b744-ff12a3144908/)

Ну, просто убранные часики, согласитесь, это, прям, совсем скучно, хоть и полезно. Давайте хотя бы сделаем так, чтобы нажатие на кнопку меняло сообщение над кнопками. Для этого удалим из кода хэндлер `process_buttons_press`, а вместо него добавим два новых хэндлера `process_button_1_press` и `process_button_2_press`. Каждый из них будет сообщать какая именно кнопка была нажата. Соответственно, оба будем регистрировать в диспетчере - каждый на свой `callback.data`.

Чтобы не отправлять в чат новое сообщение, когда мы хотим чтобы пользователь остался в рамках того же сообщения с кнопками, будем его редактировать. С помощью метода `edit_text`. 

    # ...
    
    # Этот хэндлер будет срабатывать на апдейт типа CallbackQuery
    # с data 'big_button_1_pressed'
    @dp.callback_query(Text(text=['big_button_1_pressed']))
    async def process_button_1_press(callback: CallbackQuery):
        await callback.message.edit_text(
            text='Была нажата БОЛЬШАЯ КНОПКА 1',
            reply_markup=callback.message.reply_markup)
    
    
    # Этот хэндлер будет срабатывать на апдейт типа CallbackQuery
    # с data 'big_button_2_pressed'
    @dp.callback_query(Text(text=['big_button_2_pressed']))
    async def process_button_2_press(callback: CallbackQuery):
        await callback.message.edit_text(
            text='Была нажата БОЛЬШАЯ КНОПКА 2',
            reply_markup=callback.message.reply_markup)
    
    # ...

Параметр `reply_markup=callback.message.reply_markup` говорит о том, что в качестве клавиатуры к измененному сообщению мы прикрепляем ту же клавиатуру, которая пришла в хэндлер вместе с апдейтом. То есть, мы будем менять только текст над кнопками, а сами кнопки оставлять такими же.

Вот как это работает:

![](https://ucarecdn.com/ae8d2618-2878-466f-b207-c026d4bf7b7e/)

Обратили внимание на то, что если два раза подряд нажать на одну и ту же кнопку, часики зависают надолго? Если в этот момент посмотреть в терминал - можно увидеть, что получено исключение вида:

    aiogram.exceptions.TelegramBadRequest: Telegram server says Bad Request: message is not modified: specified new message content and reply markup are exactly the same as a current content and reply markup of the message

То есть, если мы пользуемся методом `edit_text`, но при этом никак не меняем сообщение - приходит такое исключение. Работа бота не останавливается, но зависшие часики говорят, что что-то пошло не по плану. Это надо учитывать при проектировании бота - на нажатие кнопки нужно либо как-то менять сообщение, либо просто отправлять `callback.answer()`. Можно, конечно, обернуть все в `try/except`, ловить исключение и, в случае исключения, отправлять `callback.answer()`, но лучше сразу проектировать код так, чтобы таких исключений не возникало. В нашем простом примере можно проверять с каким текстом пришел апдейт и в случае, если этот текст такой же, как мы хотим отправить - не отправлять его, а сразу отправить `callback.answer()`. Перепишем немного наши хэндлеры.

    # ...
    
    # Этот хэндлер будет срабатывать на апдейт типа CallbackQuery
    # с data 'big_button_1_pressed'
    @dp.callback_query(Text(text=['big_button_1_pressed']))
    async def process_button_1_press(callback: CallbackQuery):
        if callback.message.text != 'Была нажата БОЛЬШАЯ КНОПКА 1':
            await callback.message.edit_text(
                text='Была нажата БОЛЬШАЯ КНОПКА 1',
                reply_markup=callback.message.reply_markup)
        await callback.answer()
    
    
    # Этот хэндлер будет срабатывать на апдейт типа CallbackQuery
    # с data 'big_button_2_pressed'
    @dp.callback_query(Text(text=['big_button_2_pressed']))
    async def process_button_2_press(callback: CallbackQuery):
        if callback.message.text != 'Была нажата БОЛЬШАЯ КНОПКА 2':
            await callback.message.edit_text(
                text='Была нажата БОЛЬШАЯ КНОПКА 2',
                reply_markup=callback.message.reply_markup)
        await callback.answer()
    
    #...

Проверьте. Теперь никаких исключений не возбуждается и часики надолго не зависают.

Как вы, наверное, уже догадались, при нажатии на кнопку, можно менять не только сообщение, но и клавиатуру под ним, отправляя новые кнопки в любой конфигурации. Это позволяет делать сложные разветвленные меню, что актуально для многих задач - от навигации по базе данных с товарами, до сложных настроек устройств умного дома.

Итак, еще раз принцип работы с инлайн-кнопками с параметром `callback_data`:

1.  Создаем инлайн-кнопки с текстом, который будет отображаться на кнопке, и текстом в `callback_data`, который будет приходить в апдейте типа `CallbackQuery` в поле `data`.
2.  Создаем объект инлайн-клавиатуры и добавляем в него массив массивов кнопок (параметр `inline_keyboard`)
3.  Отправляем инлайн-клавиатуру, вместе с текстом сообщения, пользователю
4.  Методом `callback_query` у диспетчера (роутера) ловим апдейт типа `CallbackQuery`, отфильтровываем его по полю `data` и направляем в соответствующий хэндлер
5.  В хэндлере либо модифицируем сообщение (текст и/или кнопки), либо отправляем пустой ответ `callback.answer()`, чтобы у пользователя не было ощущения, что бот завис в задумчивости
6.  Повторяем сначала - столько раз, сколько необходимо

**Примечание 1.** Текст в параметре `callback_data` может быть от 1 до 64 символов.

**Примечание 2.** Мы пользуемся инструкцией `callback.answer()`, чтобы сообщить телеграму о том, что мы приняли callback и обработали его. На всякий случай уточню, что callback здесь - это экземпляр класса `CallbackQuery`, который попадает в хэндлеры, то есть он не обязательно должен называться именно `callback`. Это мы его так называем для удобства, когда описываем работу хэндлера. Никто не мешает нам назвать его как-то по-другому и, когда вы будете изучать код ботов других разработчиков - вы будете встречать другие названия этого параметра. Например, `call` или `cb`, или `clbck` и т.п.