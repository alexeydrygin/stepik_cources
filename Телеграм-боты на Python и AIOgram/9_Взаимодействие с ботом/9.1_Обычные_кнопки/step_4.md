## KeyboardBuilder ("строитель клавиатур")
---------------------------------------

На предыдущих шагах мы с вами составляли клавиатуры из кнопок, основываясь на принципе, что клавиатура - это массив массивов кнопок (список списков кнопок, в рамках Python). И для некоторых простых случаев, когда кнопок не много и они особо не меняются в процессе взаимодействия с ботом - можно напрямую этим принципом пользоваться. Но согласитесь, было бы удобнее не думать о том, как именно располагать списки кнопок внутри основного списка. Хотелось бы просто создать объекты кнопок, указать какие-нибудь параметры (количество кнопок в ряду, например) и чтобы кнопки автоматически заняли свои места в списке списков. И, разумеется, такой способ есть. С помощью специального класса в `aiogram.utils.keyboard` - `ReplyKeyboardBuilder`, у которого есть удобные методы для манипулирования кнопками в клавиатуре. Принцип создания клавиатур с помощью билдера следующий:

1.  Импортируем `ReplyKeyboardBuilder` из `aiogram.utils.keyboard`
    
        from aiogram.utils.keyboard import ReplyKeyboardBuilder
    
2.  Инициализируем объект билдера
    
        kb_builder: ReplyKeyboardBuilder = ReplyKeyboardBuilder()
    
3.  Создаем список с кнопками (например, 10 кнопок)
    
        buttons: list[KeyboardButton] = [KeyboardButton(
                        text=f'Кнопка {i + 1}') for i in range(10)]
    
4.  Методами билдера добавляем в него кнопки (возьмем для примера метод `row()`)
    
        kb_builder.row(*buttons)
    
5.  Методом `as_markup()` передаем клавиатуру как аргумент туда, где она требуется
    
        await message.answer(text='Вот такая получается клавиатура',
                             reply_markup=kb_builder.as_markup())
    

Остановимся подробнее на методах класса `ReplyKeyboardBuilder`.

### Метод row()

Метод `row` у класса `ReplyKeyboardBuilder` позволяет расположить кнопки клавиатуры автоматически, в зависимости от параметра `width` - желаемого количества кнопок в ряду. "Лишние" кнопки переносятся на следующий ряд.

Не смотря на то, что Телеграм, как мы выяснили на предыдущем шаге, позволяет в одном ряду разместить до 12 кнопок, "строитель клавиатур" позволит разместить не больше 8. Попытка указать `width` больше 8 приведет к ошибке. 

**Пример 1.** Автоматическое размещение 10 кнопок с параметром `width=4`

    # Инициализируем билдер
    kb_builder: ReplyKeyboardBuilder = ReplyKeyboardBuilder()
    
    # Создаем список с кнопками
    buttons: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кнопка {i + 1}') for i in range(10)]
    
    # Распаковываем список с кнопками в билдер, указываем, что
    # в одном ряду должно быть 4 кнопки
    kb_builder.row(*buttons, width=4)
    
    
    # Этот хэндлер будет срабатывать на команду "/start"
    # и отправлять в чат клавиатуру
    @dp.message(CommandStart())
    async def process_start_command(message: Message):
        await message.answer(text='Вот такая получается клавиатура',
                             reply_markup=kb_builder.as_markup(
                                                resize_keyboard=True))

Результат такой:

![](https://ucarecdn.com/f9a25d89-a20a-487e-9fe2-af85ec26e15d/-/preview/-/enhance/83/)

Обратите внимание, что параметр `resize_keyboard=True`, отвечающий за размер кнопок, который мы раньше передавали в `ReplyKeyboardMarkup`, теперь передается в метод билдера `as_markup()`, который, по сути, и превращает билдер в объект клавиатуры `ReplyKeyboardMarkup`.

**Пример 2.** Автоматическое размещение 8 кнопок с параметром `width=3`

    # Инициализируем билдер
    kb_builder: ReplyKeyboardBuilder = ReplyKeyboardBuilder()
    
    # Создаем список с кнопками
    buttons: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кнопка {i + 1}') for i in range(8)]
    
    # Распаковываем список с кнопками в билдер, указываем, что
    # в одном ряду должно быть 3 кнопки
    kb_builder.row(*buttons, width=3)
    
    
    # Этот хэндлер будет срабатывать на команду "/start"
    # и отправлять в чат клавиатуру
    @dp.message(CommandStart())
    async def process_start_command(message: Message):
        await message.answer(text='Вот такая получается клавиатура',
                             reply_markup=kb_builder.as_markup(
                                                resize_keyboard=True))

Результат:

![](https://ucarecdn.com/a4916511-cc70-4ae0-b569-6deb11178214/-/preview/-/enhance/80/)

В общем, думаю, смысл понятен. Кнопки красиво выстраиваются сами, в зависимости от того, сколько максимально мы хотим кнопок видеть в одном ряду.

Причем, метод `row()` можно вызывать у билдера несколько раз и каждый раз новые кнопки будут начинаться с нового ряда.

**Пример 3.** Автоматическое размещение сначала 6-ти кнопок с параметром `width=4`, а затем еще 4-х кнопок с параметром `width=3`

    # Инициализируем билдер
    kb_builder: ReplyKeyboardBuilder = ReplyKeyboardBuilder()
    
    # Создаем первый список с кнопками
    buttons_1: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кнопка {i + 1}') for i in range(6)]
    
    # Создаем второй список с кнопками
    buttons_2: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кнопка {i + 7}') for i in range(4)]
    
    # Распаковываем список с кнопками в билдер, указываем, что
    # в одном ряду должно быть 4 кнопки
    kb_builder.row(*buttons_1, width=4)
    
    # Еще раз распаковываем список с кнопками в билдер, указываем, что
    # теперь в одном ряду должно быть 3 кнопки
    kb_builder.row(*buttons_2, width=3)
    
    
    # Этот хэндлер будет срабатывать на команду "/start"
    # и отправлять в чат клавиатуру
    @dp.message(CommandStart())
    async def process_start_command(message: Message):
        await message.answer(text='Вот такая получается клавиатура',
                             reply_markup=kb_builder.as_markup(
                                                resize_keyboard=True))

Как видно, добавление второго списка кнопок методом `row()` начинается с нового ряда:

![](https://ucarecdn.com/45544097-d7ea-447e-b4bd-3b9e716c2f87/-/preview/-/enhance/80/)

### Метод add()

В отличие от метода `row()` метод `add()` добавляет кнопки с нового ряда только если в предыдущем ряду для новых кнопок уже нет места. Причем, методу `add` все равно какой там у вас был параметр `width` до этого. Кнопки будут добавляться в ряд пока их там не станет 8 и только потом начнут заполнять новый ряд. Тоже до 8 штук.

**Пример 4.** Создадим клавиатуру, в которую добавим 5 кнопок методом `row` с параметром `width=4`, а затем добавим еще 10 кнопок методом `add`.

    # Инициализируем билдер
    kb_builder: ReplyKeyboardBuilder = ReplyKeyboardBuilder()
    
    # Создаем первый список с кнопками
    buttons_1: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кн. {i + 1}') for i in range(5)]
    
    # Создаем второй список с кнопками
    buttons_2: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кн. {i + 6}') for i in range(10)]
    
    # Распаковываем список с кнопками в билдер методом row,
    # указываем, что в одном ряду должно быть 4 кнопки
    kb_builder.row(*buttons_1, width=4)
    
    # Распаковываем второй список с кнопками методом add
    kb_builder.add(*buttons_2)
    
    
    # Этот хэндлер будет срабатывать на команду "/start"
    # и отправлять в чат клавиатуру
    @dp.message(CommandStart())
    async def process_start_command(message: Message):
        await message.answer(text='Вот такая получается клавиатура',
                             reply_markup=kb_builder.as_markup(
                                                resize_keyboard=True))

Получаем результат:

![](https://ucarecdn.com/c94f725d-e897-416f-817a-df253d9786b9/-/preview/-/enhance/80/)

То есть, как я и говорил выше, кнопки, добавленные методом `add`, сначала заполнили до 8 штук второй ряд, который был сформирован автоматически методом row, а затем стали заполнять следующий ряд. Если мы еще раз вызовем метод `add` у билдера и передадим ему еще кнопок - они также сначала будут заполнять до 8 предыдущий незаполненный ряд.

Вам не кажется такое поведение странным? Мы стараемся, размещаем кнопки автоматически красиво, в зависимости от желаемого количества кнопок в ряду, а тут приходит метод `add` и всю красоту ломает. Зачем? А дело в том, что `add` удобно использовать в связке с другим методом - `adjust`, с помощью которого можно явно указать какое количество кнопок должно быть в каждом ряду.

### Метод adjust()

Чтобы указать какое количество кнопок должно быть в каждом ряду - нужно передать в метод `adjust` целые числа (от 1 до 8), начиная с первого ряда. Причем данный метод будет игнорировать параметр `width`, если кнопки были добавлены в билдер методом `row`.

Можно указывать количество кнопок не для всех рядов. Тогда последующие ряды будут заполняться кнопками по значению последнего переданного аргумента. То есть, если у нас 7 кнопок, а мы в `adjust` добавили 2 и 1, то в первом ряду будет 2 кнопки, а во втором и последующих по одной.

**Пример 5.** Создадим клавиатуру, добавив 8 кнопок методом `add` и расставим их так, чтобы в 1-м ряду была одна кнопка, во втором - 3, а остальные расставились бы автоматически.

    # Инициализируем билдер
    kb_builder: ReplyKeyboardBuilder = ReplyKeyboardBuilder()
    
    # Создаем первый список с кнопками
    buttons_1: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кнопка {i + 1}') for i in range(8)]
    
    # Распаковываем список с кнопками методом add
    kb_builder.add(*buttons_1)
    
    # Явно сообщаем билдеру сколько хотим видеть кнопок в 1-м и 2-м рядах
    kb_builder.adjust(1, 3)
    
    
    # Этот хэндлер будет срабатывать на команду "/start"
    # и отправлять в чат клавиатуру
    @dp.message(CommandStart())
    async def process_start_command(message: Message):
        await message.answer(text='Вот такая получается клавиатура',
                             reply_markup=kb_builder.as_markup(
                                                resize_keyboard=True))

Смотрим на результат:

![](https://ucarecdn.com/321d019f-7372-4f4b-906c-1493385b48da/-/crop/637x322/1,0/-/preview/-/enhance/78/)

Ну, вот, как мы и хотели - в первом ряду одна кнопка, во втором - 3. В третьем тоже 3, потому что оставшиеся кнопки не превышают в своем количестве значения последнего переданного аргумента в `adjust`, ну и на 4-й ряд перешла последняя оставшаяся кнопка.

Если после метода `adjust` мы будем добавлять еще кнопки методом `row` - они начнут добавляться с нового ряда, а если методом `add`, то будут заполнять последний ряд до 8 кнопок, также как это было в предыдущих примерах.

Также у метода `adjust` есть параметр `repeat`, который по умолчанию равен `False`. Если сделать его `True`, то значения количества кнопок по рядам будут повторяться для новых рядов с кнопками.

**Пример 6.** Создадим клавиатуру с 10 кнопками, переданными в билдер методом `add` и методом `adjust` разместим их по две в каждом нечетном ряду и по 1 в каждом четном.

    # Инициализируем билдер
    kb_builder: ReplyKeyboardBuilder = ReplyKeyboardBuilder()
    
    # Создаем первый список с кнопками
    buttons_1: list[KeyboardButton] = [KeyboardButton(
                    text=f'Кнопка {i + 1}') for i in range(10)]
    
    # Распаковываем список с кнопками методом add
    kb_builder.add(*buttons_1)
    
    # Явно сообщаем билдеру сколько хотим видеть кнопок в 1-м и 2-м рядах,
    # а также говорим методу повторять такое размещение для остальных рядов
    kb_builder.adjust(2, 1, repeat=True)
    
    
    # Этот хэндлер будет срабатывать на команду "/start"
    # и отправлять в чат клавиатуру
    @dp.message(CommandStart())
    async def process_start_command(message: Message):
        await message.answer(text='Вот такая получается клавиатура',
                             reply_markup=kb_builder.as_markup(
                                                resize_keyboard=True))

Проверяем результат:

![](https://ucarecdn.com/c47ec021-f002-4142-b9ed-ff4ca0a8343f/)

Кажется, все получилось как и было задумано!

И еще давайте кратко остановимся на методе `as_markup()`

### Метод as\_markup()

На предыдущем шаге мы параметру `reply_markup` передавали объект типа `ReplyKeyboardMarkup` с некоторыми параметрами (в частности, `keyboard` и `resize_keyboard`), потому что `reply_markup` как раз и может принять такие объекты. Так вот метод `as_markup` превращает билдер в объект `ReplyKeyboardMarkup`, передавая ему в качестве аргументов клавиатуру, которую мы в билдере построили как массив массивов с кнопками, а также другие дополнительные аргументы.

Если обратиться к документации и посмотреть как именно он это делает, то можно увидеть еще один метод билдера - `export()`, который как раз возвращает массив массивов кнопок. Этот массив массивов подставляется как аргумент в `keyboard` объекта `ReplyKeyboardMarkup`, а дополнительные аргументы, которые мы можем передать в метод `as_markup` тоже передаются в объект `ReplyKeyboardMarkup` по своим ключам (`resize_keyboard`, `one_time_keyboard`, `input_field_placeholder` и так далее). Можете посмотреть все доступные параметры в [документации](https://core.telegram.org/bots/api#replykeyboardmarkup) к Telegram Bot API к типу `ReplyKeyboardMarkup`, если хотите еще раз увидеть какие именно доступны в рамках API. О некоторых из них мы будем говорить на следующем шаге урока.

У билдера существует еще ряд методов, но на практике они требуются сильно реже, чем рассмотренные в этом шаге. Если захотите углубиться - вот [ссылка](https://docs.aiogram.dev/en/dev-3.x/utils/keyboard.html) на соотвествующий раздел документации к фреймворку.

Вот так, комбинируя методы билдера, можно создавать клавиатуры с разной конфигурацией расположения кнопок.