А теперь интегрируем это в нашего Telegram-бота. Сейчас я сделаю функцию, которая будет добавлять в базу данных каждого, кто написал /start, это позволит вести учёт пользователей, да и вообще создавать его профиль для дальнейшей работы с ним.

    async def add_user(user_id, full_name, username):
        pass
    
    
    @dp.message(Command('start'))
    async def start_command(message: types.Message) -> None:
        await add_user(message.from_user.id, message.from_user.full_name, message.from_user.username)
        await message.answer('Добро пожаловать!')

В первую очередь я создал заглушку, в которую будут передаваться все необходимые данные для добавления пользователя в базу данных. 

Есть такой важный момент: сначала ты должен сделать какое-либо действие, а только потом заявить об его успешности. И я говорю сейчас не только о ботах. Поэтому, **отправку сообщения пользователю всегда ставь самой последней, а перед ней всю работу с базой и прочие манипуляции.**

    import aiosqlite
    
    async def add_user(user_id, full_name, username):
        connect = await aiosqlite.connect('db')
        cursor = await connect.cursor()
        await cursor.execute('INSERT INTO users (user_id, full_name, username) VALUES (?, ?, ?)',
                             (user_id, full_name, username))
        await connect.commit()
        await cursor.close()
        await connect.close()

Посмотрим что получилось. Во-первых, импортировали новую библиотеку - aiosqlite. На самом деле есть споры, действительно ли нужна асинхронность для работы с файлами, но я предпочитаю всё же использовать её.

В первую очередь мы подключаемся к базе данных, потом создаём курсор, с помощью которого уже будем выполнять SQL запросы, ну и наконец третьей строчкой идёт сам запрос. Можно заметить, что в _VALUES_ я подставил знаки вопроса, а переменные для добавления вынес за скобки. Это позволяет избежать негативных моментов с SQL-инъекциями, о которых я говорил в самом начале курса.

После этого идёт не совсем понятная строчка _connect.commit()._ На самом деле она отвечает за сохранение данных, если её не ввести, то твой _INSERT_ просто не сработает. При этом заметь, что она нужна только при изменении базы данных (_INSERT, UPDATE, DELETE_), но при этом не нужна при том же _SELECT_, который просто берёт информацию из базы.

Последние 2 строчки закрывают подключение к базе. И тем самым мы имеем готовую функцию для добавления пользователя в базу. Но возникает проблемка: если он 2 раза нажмёт /start, то в базе будет уже 2 одинаковых записи, а это нам не надо.

Варианта решения тут тоже два. Первый заключается в том, чтобы сделать значение user\_id уникальным (так, на самом деле, надо сделать в любом случае), и просто в слепую добавлять и ловить ошибку, что нельзя добавлять из-за уникальности. Второй вариант мне нравится больше, его суть в том, чтобы перед добавлением проверять, есть ли в базе человек, и если нет, то добавлять.

    async def add_user(user_id, full_name, username):
        connect = await aiosqlite.connect('db')
        cursor = await connect.cursor()
        check_user = await cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
        check_user = await check_user.fetchone()
        if check_user is None:
            await cursor.execute('INSERT INTO users (user_id, full_name, username) VALUES (?, ?, ?)',
                                 (user_id, full_name, username))
            await connect.commit()
        await cursor.close()
        await connect.close()

Вот так незамысловатый, но очень практичный код у нас получился. Теперь можно не бояться, что кто-то заспамит кнопку /start.