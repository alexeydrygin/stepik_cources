## 1.1 Для кого этот курс
3 из 10 шагов пройдено  
0 из 12 баллов  получено

_Убедительная просьба: не игнорировать видео. Эти тезисы нужны лишь для того, чтобы ты вспомнил определенные моменты из видео, а вместе с ними всё то, что рассказывал автор._  
  
**Основные тезисы из видео про асинхронность:**

1.  Асинхронность, многопоточность и многопроцессность - разные вещи.
2.  При синхронном коде каждая функция выполняется последовательно друг за другом и ожидает завершения предыдущей. Пока предыдущая функция не будет завершена - вся программа стоит в ожидании.
3.  Многопроцессность необходима для обработки тяжёлых задач, например, рендеринг видео. Его особенность в том, что он создаёт отдельный процесс, и занимает самостоятельно все необходимые ему ресурсы.
4.  В питоне возможно исполнение только одного потока в текущий момент времени, поэтому система работает следующим образом: когда какой-то поток простаивает, его ресурсы передаются для выполнения другого. Именно поэтому нельзя делать выводить рендеринг видео в отдельный поток, оно просто сожрёт все ресурсы программы и она зависнет, так как нет возможности питать другие потоки.
5.  На переключение потоков тратится время. Когда их становится слишком много - применение уже бесполезно.
6.  Асинхронный код работает следующим образом: Как только код в функции останавливается (например, time.sleep) (не означает, что функция завершена), идет выполнение следующей функции с обещанием, что как только настанет время для выполнения кода в прошлой функции - он продолжит выполняться.
7.  Блокирующая функция в асинхронном коде - это та функция, из-за которой весь код не будет выполняться, пока она сама не будет исполнена (например, sleep из библиотеки time, а не из asyncio; или же input()).
8.  Асинхронный код лучше многопоточного тем, что при использовании последнего мы упираемся в проблему того, что в питоне возможно использовать лишь один поток в настоящий момент, и питон будет вынужден тратить время на смену потоков. В случае же с асинхронным кодом, весь код работает в одном потоке и питону не нужно их менять.
9.  Функции, запускающиеся из со-программ (это функции, которые запущены через asyncio.createtask) не нужно передавать в create\_task, чтобы для неё создать задачу, это произойдёт автоматически
10.  В многопоточном коде есть "режим гонки". Например, при работе со списком один поток мог изменить информацию в нём, а второму (который должен был выполниться первее) была необходима эта информация, и начинаются проблемы. В асинхронном коде такой проблемы нет.
11.  Для асинхронного кода имеются свои асинхронные библиотеки, чтобы нигде не возникало блокирующих функций (Requests - Aiohttp; PyTelegramBotApi - Aiogram; Sqlite3 - Aiosqlite; Redis - Aioredis и др.).
12.  Асинхронность, многопоточность и многопроцессность можно комбинировать.